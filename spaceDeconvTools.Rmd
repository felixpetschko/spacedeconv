---
title: "spaceDeconv "
output: 
  html_document:
      toc: true
      toc_float: true
date: "2022-06-13"
author: Constantin Zackl
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

In the following all deconvolution tools for spaceDeconv are tested and run once to showcase and test all tools.


## Imports and Python Setup
```{r imports, echo=TRUE, results="hide", message=FALSE}
library(reticulate)
library(TENxVisiumData) # data
library(TabulaMurisSenisData) # data
library(ggspavis) # visualization
library(SPOTlight)
```
```{r python, echo=TRUE}
# setup python
reticulate::use_condaenv("cell2loc_env")
scanpy <- reticulate::import("scanpy")
reticulate::py_available()
```



## Datasets
We are using two sample datasets from mouse kidneys.


```{r Datasets, echo=TRUE, results='hide', message=FALSE, warning=FALSE, error=FALSE}
# Spatial
sp <- TENxVisiumData::MouseKidneyCoronal()
rownames(sp) <- rowData(sp)$symbol # overwrite EnsemblID

# Single Cell 
sc <- TabulaMurisSenisData::TabulaMurisSenisDroplet(tissues= "Kidney")$Kidney
```

Let's have a look inside the datasets. The console output shows the available cell types and the corresponding number of available cells. The Plot visualizes the number of gene counts per spot and the corresponding Visium Image.


```{r datasetPlots, echo=FALSE, out.width="50%"}
knitr::kable(table(sc$free_annotation, sc$age))

# calculate total counts
colData(sp)$nCounts <- colSums(counts(sp))
x <- "pxl_row_in_fullres" # x coord
y <- "pxl_col_in_fullres" # y coord, from spatialCoords(sp)
ggspavis::plotSpots(sp, x, y, annotate="nCounts", size=2)
ggspavis::plotVisium(sp, x_coord = x, y_coord =  y, spots = FALSE)

```



## Preprocessing

We subset the cells to remove unsuitable cells and NAs. We further subset cells for performance reasons. In a full run this step will be skipped.

This section will further include normalization steps.

```{r preprocessing}
# We are only using data from 18m old cells
sc <- sc[, sc$age=="18m"]
sc <- sc[, !sc$free_annotation %in% c("nan", "CD45")] # remove false data

# downsampling for performance reasons, copied from MarcElosua/SPOTlight
idx <- split(seq(ncol(sc)), sc$free_annotation)
n_cells <- 50
cs_keep <- lapply(idx, function(i) {
    n <- length(i)
    if (n < n_cells)
        n_cells <- n
    sample(i, n_cells)
})
sc <- sc[, unlist(cs_keep)]

```



## SPOTlight

Marker Genes are necessary for SPOTlight. Here i follow the guideline presented on their website. This could be done differently.
A vector of highly variable Genes is also helpful but not required.

```{r SPOTligthParameters}
# SPOTligth parameters
slot <- "cell_ontology_class" # where are the cell types stored, find better term for "slot"
mgs <- NULL # DataFrame of scored Marker genes
# + obviously the single cell and spatial dataset
```



```{r SPOTlight}
colLabels(sc) <- colData(sc)[[slot]] # add Labels

# norm 
sc <- scuttle::logNormCounts(sc) # score marksers

mgs <- scran::scoreMarkers(sc) # can include a subset step, requires logcounts slot/assay?

# this code is from the vignette
# one could perform this differently but the final dataframe needs to be present
mgs_fil <- lapply(names(mgs), function(i) {
  x <- mgs[[i]]
  # Filter and keep relevant marker genes, those with AUC > 0.8
  x <- x[x$mean.AUC > 0.8, ]
  # Sort the genes from highest to lowest weight
  x <- x[order(x$mean.AUC, decreasing = TRUE), ]
  # Add gene and cluster id to the dataframe
  x$gene <- rownames(x)
  x$cluster <- i
  data.frame(x)
})
mgs_df <- do.call(rbind, mgs_fil)

deconvolution <- SPOTlight::SPOTlight(sc, sp, mgs=mgs_df, weight_id = "mean.AUC", verbose=TRUE)
deconvolution <- deconvolution$mat # extract the result
knitr::kable(head(deconvolution[, 4:6])) # just a subset

```
```{r addToObject, echo=TRUE, message = FALSE}
# adding the results to colData
colnames(deconvolution) <- make.names(colnames(deconvolution))

for (i in colnames(deconvolution)){ # each separately
  sp[[i]] <- deconvolution[, i] 
}

# the colData annotation of the spatialExperiment now looks like this:
names(colData(sp))
```
```{r plottingSpotlight, echo=FALSE}
# Visualization of some examples
# x and y from above
ggspavis::plotSpots(sp, x, y, annotate = "kidney.cortex.artery.cell", size=2)
ggspavis::plotSpots(sp, x, y, annotate = "kidney.loop.of.Henle.thick.ascending.limb.epithelial.cell", size=1)
ggspavis::plotSpots(sp, x, y, annotate = "kidney.proximal.convoluted.tubule.epithelial.cell", size=1)
ggspavis::plotSpots(sp, x, y, annotate = "NK.cell", size=2)
```
```{r plottingSpotlightVisium, echo=FALSE}
# You could overlay the image
ggspavis::plotVisium(sp, x_coord = x, y_coord = y, fill="NK.cell", palette = c("red", "white"))
# here white means a higher NK amount, note the red circle in the middle
```

## RCTD (spacexr)

```{r rctdsetup}
library(spacexr)
sc2 <- sc # using a copy in this case because we are removing cells

# first subset the sc reference, every cell type needs to be present more than 25 times!!!!!
cellTable <- as.data.frame(table(sc2[["cell_ontology_class"]])) # table of all factors and their count
cellTable <- cellTable[cellTable$Freq>=25,] # drop all below 25
cellsToKeep <- as.character(cellTable$Var1) # character vector for subsetting

sc2 <- sc2[, sc2[["cell_ontology_class"]] %in% cellsToKeep] # subset cells (columns)
sc2[["cell_ontology_class"]] <- droplevels(sc2[["cell_ontology_class"]]) # drop zero levels in factor

```

#### Construct Single Cell Reference
```{r rctdSC}
# counts as dgC 
counts <- as(counts(sc2), "dgCMatrix")  # convert from delayed matrix to dgC

# named cell type factor
cell_types <- colData(sc2)[, "cell_ontology_class"] # get cell type factor
names(cell_types) <- rownames(colData(sc2)) # name it!
cell_types <- as.factor(cell_types) # ensure factor

# named Umi Count
nUMI <- colData(sc2)[, "n_counts"]
names(nUMI) <- rownames(colData(sc2)) # name it!

# create Reference
reference <- spacexr::Reference(counts, cell_types, nUMI)

```

#### Construct Spatial Dataset
```{r rctdSP}
coords <- SpatialExperiment::spatialCoords(sp) # spatial coordinates
coords <- as.data.frame(coords)
counts <- counts(sp) # counts
nUMI <- colData(sp)[, "nCounts"] 
# all three above are already named but that does not have to be the case

# in this specific case we must make gene names unique! There are duplicates
rownames(counts) <- make.names(rownames(counts), unique=T)

puck <- spacexr::SpatialRNA(coords, counts, nUMI)
```

#### Create RCTD Object and run
```{r rctdRUN, echo=TRUE, message=FALSE, error=FALSE}
RCTDObject <- spacexr::create.RCTD(puck, reference, max_cores = 3, UMI_min = 0) # NOTE UMI_min = 0!!!!
RCTDObject <- spacexr::run.RCTD(RCTDObject)

results <- RCTDObject@results
norm_weights <- spacexr::normalize_weights(results$weights) # normalize the weights to sum to one
norm_weights <- as.matrix(norm_weights)
```


#### Plot Results
```{r rctdResults, echo=FALSE}
colnames(norm_weights) <- make.names(colnames(norm_weights))

for (i in colnames(norm_weights)){ # each separately
  sp[[i]] <- norm_weights[, i] 
}

ggspavis::plotSpots(sp, x, y, annotate = "kidney.cortex.artery.cell", size=2)
ggspavis::plotSpots(sp, x, y, annotate = "kidney.loop.of.Henle.thick.ascending.limb.epithelial.cell", size=1)
ggspavis::plotSpots(sp, x, y, annotate = "kidney.proximal.convoluted.tubule.epithelial.cell", size=1)
ggspavis::plotSpots(sp, x, y, annotate = "brush.cell", size=2)
```

## omnideconv

Omnideconv does take singleCellExperiments as input! The bulk needs to be a matrix and can be extracted by counts(sp). batch IDs can also be extracted from the singleCellExperiment.

NOTE: This omnideconv example worked but i had some errors with different methods. This is to showcase the overall omnideconv usage in spaceDeconv.

```{r}
library(omnideconv)
```

### Single Cell Reference
```{r omnideconvSignature, echo=TRUE, message=FALSE, warning=FALSE, error=FALSE}
# works directly with the singleCellExperiment
batch_ids <- colData(sc)$mouse.id # batch id not cell id!!!!

signature <- omnideconv::build_model(sc, method = "scdc", cell_type_column_name = "cell_ontology_class", batch_ids = batch_ids, verbose=TRUE) 
```

### Deconvolution
```{r omnideconvDeconvolution, echo=TRUE, message=FALSE, warning=FALSE, error=FALSE}
# this spatial dataset has duplicate rownames
rownames(sp) <- make.names(rownames(sp), unique = T)

#extract bulk matrix
bulk <- counts(sp) # could be different!

# deconvolute
deconvolution <- omnideconv::deconvolute(bulk, signature=signature, method="scdc", verbose=TRUE, single_cell_object=sc, cell_type_column_name = "cell_ontology_class", batch_ids = batch_ids)

```

```{r omnidconvAddResult, echo=FALSE}
colnames(deconvolution) <- make.names(colnames(deconvolution)) # removing the whitespace

for (i in colnames(deconvolution)){ # each separately
  sp[[i]] <- deconvolution[, i] 
}

ggspavis::plotSpots(sp, x, y, annotate = "kidney.cortex.artery.cell", size=2)
ggspavis::plotSpots(sp, x, y, annotate = "kidney.loop.of.Henle.thick.ascending.limb.epithelial.cell", size=1)
ggspavis::plotSpots(sp, x, y, annotate = "kidney.proximal.convoluted.tubule.epithelial.cell", size=1)
ggspavis::plotSpots(sp, x, y, annotate = "brush.cell", size=2)
```

## Immunedeconv

Note: Immundeconv requires HGNC Symbols. This might not be the case for all datasets so we should add a note/ give options to translate the names???

```{r echo=TRUE, message=FALSE, error=FALSE, warning=FALSE}
library(immunedeconv)
```

```{r, echo=TRUE, message=FALSE, error=FALSE, warning=FALSE}
# needs to be a real matric or Data Frame
bulk <- counts(sp)
bulk <- as.matrix(bulk) # make.names already called

# HGNC Symbols! In this case just uppercase is enough
rownames(bulk) <- toupper(rownames(bulk))

deconvolution <- immunedeconv::deconvolute(bulk, method="epic")
```

```{r}
# move first column to colnames
deconvolution <- as.matrix(deconvolution)
rownames <- deconvolution[, 1]
deconvolution <- deconvolution[, -1]
deconvolution <- apply(deconvolution, 2, as.numeric) # turn into numeric
rownames(deconvolution) <- rownames

# transpose
deconvolution <- t(deconvolution)

colnames(deconvolution) <- make.names(colnames(deconvolution)) # removing the whitespace

for (i in colnames(deconvolution)){ # each separately
  sp[[i]] <- deconvolution[, i] 
}
```
```{r echo=FALSE}
ggspavis::plotSpots(sp, x, y, annotate = "B.cell", size=2)
ggspavis::plotSpots(sp, x, y, annotate = "Macrophage", size=2)
ggspavis::plotSpots(sp, x, y, annotate = "Endothelial.cell", size=2)
ggspavis::plotSpots(sp, x, y, annotate = "NK.cell", size=2)
```






## Cell2location