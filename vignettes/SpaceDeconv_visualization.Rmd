---
title: "SpaceDeconv Visualization"
author: "Constantin Zackl"
date: "2022-09-21"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{SpaceDeconv Visualization}
  %\VignetteEngine{knitr::knitr}
  %\VignetteEncoding{UTF-8}
---

To introduce SpaceDeconvs visualization functions we will utilize a deconvolution result obtained from internal sample data and the deconvolution method `RCTD`. Note that RCTD requires unnormalized data and is building the signature and deconvoluting in one step. Therefore only `deconvolute()` is called. 

```{r error=FALSE, message=FALSE, warning=FALSE}
library(SpaceDeconv)
data("spatial_data_2")

spatial_data_3 <- SpaceDeconv::normalize(spatial_data_3, method="cpm")

deconv <- SpaceDeconv::deconvolute(
  spatial_data_3,
  method = "quantiseq", 
  assay_sp = "cpm"
)
```

# Available Visualizations

At the moment SpaceDeconv offers two visualization functions. 

1. `plot_celltype()` visualizes the spatial image with color coded cell type fractions for one cell type. 
2. `plot_cells_per_spot()` shows a color coded distribution of the number of detected cell types for each spot. This plot can additionally rendered as a bar chart. 
3. `plot_umi_count()` Plots the number of sequenced reads per spot
4. `plot_most_abundant()` Render a plot containing the most abundant cell-type for each spot

### 1. `plot_celltype()`
```{r message=FALSE, warning=FALSE, fig.width=7, fig.height=7}
SpaceDeconv::plot_celltype(deconv, cell_type = "quantiseq_B.cell", palette = "Mako", spot_size = 1.17, smooth = F)
```

### 2. `plot_cells_per_spot()`

To render the distribution of the number of detected cell types per spot a user-selected treshold is required as well as a deconvolution result. A cell fraction above this threshold will be marked as "detected". In this example we set the treshold to 5%. 
```{r, warning=FALSE, message=FALSE, fig.height=7, fig.width=7}
SpaceDeconv::plot_cells_per_spot(deconv, threshold = 0.05, palette = "Mako", spot_size = 1.17)
```

### 3. `plot_umi_count()`
For the UMI count spot no additional information is necessary. We recommend rendering this plot with `transform_scale = "sqrt"` due to the large range of UMI counts. `

```{r plotUMIcount, fig.height=7, fig.width=7}
SpaceDeconv::plot_umi_count(deconv, palette = "Mako", spot_size = 1.17, transform_scale = "sqrt")
```
### 4. `plot_most_abundant()`
This plots displays the most abundant cell-type for each spot. You can specify which cells to plot by either one of the following: 

* `cell_type` vector of celltypes to plot 
* `method` plotting all cell types of the provided method
* `remove` vector of celltypes to be removed from the plot
```{r}
SpaceDeconv::plot_most_abundant(deconv, method="quantiseq", palette = "Viridis", spot_size = 1.17, remove = "quantiseq_uncharacterized.cell")
```


# Color Palette 
All Sequential Palettes from the [colorspace](https://colorspace.r-forge.r-project.org/) R Package can be used. 
```{r availablePalettes, fig.width=8}
colorspace::hcl_palettes(type = "sequential", plot = TRUE)
```

# Further plot adjustments

### Image Alignment Offset
SpaceDeconvs Visualization function is designed to work with data by SpaceRanger >= V2.0. Since this Version the image is rotated by default that the hourglass fiducial is in the upper left corner. Previous SpaceRanger results can be rotated differently. The rotation additionally reflects in the angle of the spots on the slide. Uncorrectly rotated images result in hexagons being rotated by 30 degrees. To compensate for this you can use the `offset_rotation` parameter to correct the hexagon alignment. This is only necessary for Visium slides where the hourglass fiducial is in the bottom left or upper right corner. 

```{r offset_rotation, eval = FALSE}
plot_umi_count(deconv, offset_rotation = T) # rotate hexagons
```
### Transform Scale 

With the `transform_scale` parameter the colorspace scale can be modified. Available options are: "ln", "log10", "log2" and "sqrt". Scaling the color range differently can aid with interpreting the plot. Please have in mind that the plot does not show valid deconvolution results anymore and should be handled with caution. 

```{r}
SpaceDeconv::plot_umi_count(deconv, palette = "Mako", spot_size = 1.17, transform_scale = "sqrt")
```


### Smooth

With this parameter the expression values can be smoothed to simplify pattern recognition. The smoother utilizes a linear kernel which size is calculated by multiplying the spot distance with the smoothing factor.

* `smooth=T` enable smoothing 
* `smoothing_factor` choose kernel size (factor of spot distance)

```{r}
SpaceDeconv::plot_celltype(deconv, cell_type = "quantiseq_B.cell", palette = "Mako", spot_size = 1.17, smooth = T, smoothing_factor = 1.5)
```

# Additional Parameters 

* `show_image` logical, show or remove the spatial image
* `spot_size` integer, increase (>1) or decrease (<1) the hexagon size
* `limits` vector containing upper and lower limits for the color scale
